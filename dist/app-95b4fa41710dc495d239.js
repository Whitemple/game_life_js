(()=>{"use strict";var __webpack_modules__={138:()=>{eval(" \n\n\n\nlet rows;\nlet columns;\n\nlet world = document.querySelector('#world');\nconst startBtn = document.querySelector('#startBtn');\nconst resetBtn = document.querySelector('#reset');\n\nconst navButtons = document.querySelector('.navButtons');\nconst initParamsBox = document.querySelector('.initParamsBox');\n\nconst mediaQuery320 = window.matchMedia('(min-width: 320px)')\nconst mediaQuery425 = window.matchMedia('(min-width: 425px)')\nconst mediaQuery768 = window.matchMedia('(min-width: 768px)')\nconst mediaQuery1024 = window.matchMedia('(min-width: 1024px)')\n\nlet started=false;// Set to true when use clicks start\nlet timer;//To control evolutions\nlet lifeSpeed = document.querySelector('#speed');\nlet lifeSpeedValue = 1000;\n\nconst modalWindowErrors = document.querySelector('.modalWindow');\n\nfunction showModalErrors(textError){\n    modalWindowErrors.style.top = \"6px\";\n    modalWindowErrors.innerHTML = textError;\n}\nfunction closeModal(){\n    modalWindowErrors.style.top = \"-50px\";\n}\n\nfunction commonFunc(textError){\n    showModalErrors(textError);\n    setTimeout(()=>{\n        closeModal()\n    },2000);\n}\n\nconst userRow = document.querySelector('#row');\nconst userColumn = document.querySelector('#column');\nconst sub = document.querySelector('#sub');\n\nsub.addEventListener('click', () => {\n\n\n    let userRowValue = userRow.value;\n    let userColumnValue = userColumn.value;\n\n    if(mediaQuery320.matches && !mediaQuery425.matches && !mediaQuery768.matches && !mediaQuery1024.matches){\n        console.log('MODILE: 320 to 424');\n        if(!Number(isNaN(userRowValue)) && userRowValue != '' && userRowValue >= 8 && userRowValue <=13){\n\n            rows = userRowValue;\n        }\n        if(!Number(isNaN(userColumnValue)) && userColumnValue != ''  && userColumnValue >= 8 && userColumnValue <=13){\n    \n            columns = userColumnValue;\n        }\n        else{\n            commonFunc('Ширина и высота должны быть от 8 до 13')\n        }\n    }\n    else if(mediaQuery320.matches && mediaQuery425.matches && !mediaQuery768.matches && !mediaQuery1024.matches){\n        console.log('TABLET: 425 to 767');\n        if(!Number(isNaN(userRowValue)) && userRowValue != '' && userRowValue >= 10 && userRowValue <= 17){\n\n            rows = userRowValue;\n        }\n        if(!Number(isNaN(userColumnValue)) && userColumnValue != ''  && userColumnValue >= 10 && userColumnValue <= 17){\n    \n            columns = userColumnValue;\n        }\n        else{\n            commonFunc('Ширина и высота должны быть от 10 до 17')\n        }\n    }\n    else if(mediaQuery320.matches && mediaQuery425.matches && mediaQuery768.matches && !mediaQuery1024.matches){\n        console.log('LITLE DESKTOP: 768 to 1023');\n        if(!Number(isNaN(userRowValue)) && userRowValue != '' && userRowValue >= 15 && userRowValue <= 23){\n\n            rows = userRowValue;\n        }\n        if(!Number(isNaN(userColumnValue)) && userColumnValue != ''  && userColumnValue >= 15 && userColumnValue <= 23){\n    \n            columns = userColumnValue;\n        }\n        else{\n            commonFunc('Ширина и высота должны быть от 15 до 23')\n        }\n    } \n    else if(mediaQuery320.matches && mediaQuery425.matches && mediaQuery768.matches && mediaQuery1024.matches){\n        console.log('LITLE DESKTOP: 768 to 1023');\n        if(!Number(isNaN(userRowValue)) && userRowValue != '' && userRowValue >= 15 && userRowValue <= 27){\n\n            rows = userRowValue;\n        }\n        if(!Number(isNaN(userColumnValue)) && userColumnValue != ''  && userColumnValue >= 15 && userColumnValue <= 27){\n    \n            columns = userColumnValue;\n        }\n        else{\n            commonFunc('Ширина и высота должны быть от 15 до 27')\n        }\n    } \n    \n\n    if(rows && columns){\n        navButtons.style.display = 'block';\n        initParamsBox.style.display = 'none';\n        beginWorld();\n\n\n\n    }\n    \n})\n\n\n\n\n        // Function that change speed\n        lifeSpeed.onchange = () => {\n            lifeSpeedValue = lifeSpeed.value;\n        }\n\n\n\n        // create 2D Arrays\n        let currentGeneration = [rows];\n        let nextGeneration = [rows];\n\n\n        function createGenerationArrays(){\n            for (let i = 0; i < rows; i++) {\n                currentGeneration[i] = new Array(columns);\n                nextGeneration[i] = new Array(columns);\n                \n            }\n        }\n        function initialGenerationArrays(){\n            for (let i = 0; i < rows; i++) {\n                for (let k = 0; k < columns; k++) {\n                    currentGeneration[i][k] = 0;\n                    nextGeneration[i][k] = 0;\n                }\n            }\n        }\n\n\n        // Create world by tables\n        function createWorld(){\n            let table = document.createElement('table');\n            table.setAttribute('id', 'worldGrid');\n            for(let i=0; i<rows; i++){\n                let tr = document.createElement('tr');\n                for(let k = 0; k < columns; k++){\n                    let cell = document.createElement('td');\n                    cell.setAttribute('id', i + '_' + k);\n                    cell.setAttribute('class', 'dead');\n                    tr.appendChild(cell);\n                }\n                table.appendChild(tr);\n            }\n            world.appendChild(table);\n            world.addEventListener('click', cellClick);\n            \n        }\n\n        // addEventListener\n        function cellClick(data) {\n            let loc = data.target.id.split(\"_\");\n            // console.log(loc);\n            let row = Number(loc[0]);//Get i\n            let col = Number(loc[1]);//Get j\n            // Toggle cell alive or dead\n            if(data.target.localName==='td'){\n                if (data.target.className==='alive'){\n                    data.target.setAttribute('class', 'dead');\n                    currentGeneration[row][col] = 0;\n                }\n                else{\n                    data.target.setAttribute('class', 'alive');\n                    currentGeneration[row][col] = 1;\n                }\n            }\n        }\n\n\n\n        // Cheking for neighbors and expect the rules\n        function getNeighborsCounter(row, col) {\n            let count = 0;\n            let nrow=Number(row);\n            let ncol=Number(col);\n            \n                // Make sure we are not at the first row\n                if (nrow - 1 >= 0) {\n                // Check top neighbor\n                if (currentGeneration[nrow - 1][ncol] == 1) \n                    count++;\n            }\n                // Make sure we are not in the first cell\n                // Upper left corner\n                if (nrow - 1 >= 0 && ncol - 1 >= 0) {\n                //Check upper left neighbor\n                if (currentGeneration[nrow - 1][ncol - 1] == 1) \n                    count++;\n            }\n        // Make sure we are not on the first row last column\n                // Upper right corner\n                if (nrow - 1 >= 0 && ncol + 1 < columns) {\n                //Check upper right neighbor\n                    if (currentGeneration[nrow - 1][ncol + 1] == 1) \n                        count++;\n                }\n        // Make sure we are not on the first column\n            if (ncol - 1 >= 0) {\n                //Check left neighbor\n                if (currentGeneration[nrow][ncol - 1] == 1) \n                    count++;\n            }\n            // Make sure we are not on the last column\n            if (ncol + 1 < columns) {\n                //Check right neighbor\n                if (currentGeneration[nrow][ncol + 1] == 1) \n                    count++;\n            }\n        // Make sure we are not on the bottom left corner\n            if (nrow + 1 < rows && ncol - 1 >= 0) {\n                //Check bottom left neighbor\n                if (currentGeneration[nrow + 1][ncol - 1] == 1) \n                    count++;\n            }\n        // Make sure we are not on the bottom right\n            if (nrow + 1 < rows && ncol + 1 < columns) {\n                //Check bottom right neighbor\n                if (currentGeneration[nrow + 1][ncol + 1] == 1) \n                    count++;\n            }\n            \n            \n                // Make sure we are not on the last row\n            if (nrow + 1 < rows) {\n                //Check bottom neighbor\n                if (currentGeneration[nrow + 1][ncol] == 1) \n                    count++;\n            }\n            \n            \n            return count;\n        }\n\n                // Define conditions of cell\n                function createNextGeneration() {\n                    for (let row in currentGeneration) {\n                        for (let col in currentGeneration[row]) {\n                        \n                            let neighbors = getNeighborsCounter(row, col);\n                        \n                            // Check the rules\n                            // If Alive\n                            if (currentGeneration[row][col] == 1) {\n                            \n                                if (neighbors < 2) {\n                                    nextGeneration[row][col] = 0;\n                                } else if (neighbors == 2 || neighbors == 3) {\n                                    nextGeneration[row][col] = 1;\n                                } else if (neighbors > 3) {\n                                    nextGeneration[row][col] = 0;\n                                }\n                            } else if (currentGeneration[row][col] == 0) {\n                                // If Dead or Empty\n                            \n                                if (neighbors == 3) {\n                                    // Propogate the species\n                                    nextGeneration[row][col] = 1;//Birth?\n                                }\n                            }\n                        }\n                    }\n                }\n\n        // \n\n        function updateCurrentGeneration() {\n            \n            for (let row in currentGeneration) {\n                for (let col in currentGeneration[row]) {\n                    // Update the current generation with\n                    // the results of createNextGen function\n                    currentGeneration[row][col] = nextGeneration[row][col];\n                    // Set nextGen back to empty\n                    nextGeneration[row][col] = 0;\n                }\n            }\n        \n        }\n        function updateWorld() {\n            let cell='';\n            for (let row in currentGeneration) {\n                for (let col in currentGeneration[row]) {\n                    // cell = document.getElementById(row + '_' + col);\n                    cell = document.getElementById(`${row}_${col}`);\n                    if (currentGeneration[row][col] == 0) {\n                        cell.setAttribute('class', 'dead');\n\n                    } else {\n                        cell.setAttribute('class', 'alive');\n                    }\n                }\n            }\n        }\n\n\n\n        // create startLife fucntion\n\n        function startLife(){\n            createNextGeneration();//Apply the rules\n            updateCurrentGeneration();//Set Current values from new generation\n            updateWorld();//Update the world view\n            // check()\n            if(started){\n                timer = (setTimeout(startLife, lifeSpeedValue));\n                // setTimeout(check, lifeSpeedValue)\n            }\n\n        }\n\n\n        // Function start and stop life\n        function startAndStop(){\n            if(!started){\n                started = true;\n                startBtn.innerText = 'Остановить игры';\n                startLife();\n            } else {\n                started = false;\n                startBtn.innerText = 'Начать игру!';\n                clearTimeout(timer);\n                \n            }\n\n        }\n\n        // reload page ande reset data\n        function resetData(){\n            window.location.reload();\n            navButtons.style.display = 'none';\n            initParamsBox.style.display = 'block';\n        }\n\n        startBtn.addEventListener('click', startAndStop);\n        resetBtn.addEventListener('click', resetData);\n\n\n        function beginWorld(){\n            createWorld();\n            createGenerationArrays();\n            initialGenerationArrays();\n        }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2h3XzEwX2xpZmVzaW11bGF0b3JfanMvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vaW5kZXguaHRtbCc7IFxuaW1wb3J0ICcuL2luZGV4LnNjc3MnO1xuXG5cbmxldCByb3dzO1xubGV0IGNvbHVtbnM7XG5cbmxldCB3b3JsZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN3b3JsZCcpO1xuY29uc3Qgc3RhcnRCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3RhcnRCdG4nKTtcbmNvbnN0IHJlc2V0QnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Jlc2V0Jyk7XG5cbmNvbnN0IG5hdkJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubmF2QnV0dG9ucycpO1xuY29uc3QgaW5pdFBhcmFtc0JveCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbml0UGFyYW1zQm94Jyk7XG5cbmNvbnN0IG1lZGlhUXVlcnkzMjAgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi13aWR0aDogMzIwcHgpJylcbmNvbnN0IG1lZGlhUXVlcnk0MjUgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi13aWR0aDogNDI1cHgpJylcbmNvbnN0IG1lZGlhUXVlcnk3NjggPSB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi13aWR0aDogNzY4cHgpJylcbmNvbnN0IG1lZGlhUXVlcnkxMDI0ID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtaW4td2lkdGg6IDEwMjRweCknKVxuXG5sZXQgc3RhcnRlZD1mYWxzZTsvLyBTZXQgdG8gdHJ1ZSB3aGVuIHVzZSBjbGlja3Mgc3RhcnRcbmxldCB0aW1lcjsvL1RvIGNvbnRyb2wgZXZvbHV0aW9uc1xubGV0IGxpZmVTcGVlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzcGVlZCcpO1xubGV0IGxpZmVTcGVlZFZhbHVlID0gMTAwMDtcblxuY29uc3QgbW9kYWxXaW5kb3dFcnJvcnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubW9kYWxXaW5kb3cnKTtcblxuZnVuY3Rpb24gc2hvd01vZGFsRXJyb3JzKHRleHRFcnJvcil7XG4gICAgbW9kYWxXaW5kb3dFcnJvcnMuc3R5bGUudG9wID0gXCI2cHhcIjtcbiAgICBtb2RhbFdpbmRvd0Vycm9ycy5pbm5lckhUTUwgPSB0ZXh0RXJyb3I7XG59XG5mdW5jdGlvbiBjbG9zZU1vZGFsKCl7XG4gICAgbW9kYWxXaW5kb3dFcnJvcnMuc3R5bGUudG9wID0gXCItNTBweFwiO1xufVxuXG5mdW5jdGlvbiBjb21tb25GdW5jKHRleHRFcnJvcil7XG4gICAgc2hvd01vZGFsRXJyb3JzKHRleHRFcnJvcik7XG4gICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICBjbG9zZU1vZGFsKClcbiAgICB9LDIwMDApO1xufVxuXG5jb25zdCB1c2VyUm93ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3JvdycpO1xuY29uc3QgdXNlckNvbHVtbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjb2x1bW4nKTtcbmNvbnN0IHN1YiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzdWInKTtcblxuc3ViLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuXG5cbiAgICBsZXQgdXNlclJvd1ZhbHVlID0gdXNlclJvdy52YWx1ZTtcbiAgICBsZXQgdXNlckNvbHVtblZhbHVlID0gdXNlckNvbHVtbi52YWx1ZTtcblxuICAgIGlmKG1lZGlhUXVlcnkzMjAubWF0Y2hlcyAmJiAhbWVkaWFRdWVyeTQyNS5tYXRjaGVzICYmICFtZWRpYVF1ZXJ5NzY4Lm1hdGNoZXMgJiYgIW1lZGlhUXVlcnkxMDI0Lm1hdGNoZXMpe1xuICAgICAgICBjb25zb2xlLmxvZygnTU9ESUxFOiAzMjAgdG8gNDI0Jyk7XG4gICAgICAgIGlmKCFOdW1iZXIoaXNOYU4odXNlclJvd1ZhbHVlKSkgJiYgdXNlclJvd1ZhbHVlICE9ICcnICYmIHVzZXJSb3dWYWx1ZSA+PSA4ICYmIHVzZXJSb3dWYWx1ZSA8PTEzKXtcblxuICAgICAgICAgICAgcm93cyA9IHVzZXJSb3dWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZighTnVtYmVyKGlzTmFOKHVzZXJDb2x1bW5WYWx1ZSkpICYmIHVzZXJDb2x1bW5WYWx1ZSAhPSAnJyAgJiYgdXNlckNvbHVtblZhbHVlID49IDggJiYgdXNlckNvbHVtblZhbHVlIDw9MTMpe1xuICAgIFxuICAgICAgICAgICAgY29sdW1ucyA9IHVzZXJDb2x1bW5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgY29tbW9uRnVuYygn0KjQuNGA0LjQvdCwINC4INCy0YvRgdC+0YLQsCDQtNC+0LvQttC90Ysg0LHRi9GC0Ywg0L7RgiA4INC00L4gMTMnKVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYobWVkaWFRdWVyeTMyMC5tYXRjaGVzICYmIG1lZGlhUXVlcnk0MjUubWF0Y2hlcyAmJiAhbWVkaWFRdWVyeTc2OC5tYXRjaGVzICYmICFtZWRpYVF1ZXJ5MTAyNC5tYXRjaGVzKXtcbiAgICAgICAgY29uc29sZS5sb2coJ1RBQkxFVDogNDI1IHRvIDc2NycpO1xuICAgICAgICBpZighTnVtYmVyKGlzTmFOKHVzZXJSb3dWYWx1ZSkpICYmIHVzZXJSb3dWYWx1ZSAhPSAnJyAmJiB1c2VyUm93VmFsdWUgPj0gMTAgJiYgdXNlclJvd1ZhbHVlIDw9IDE3KXtcblxuICAgICAgICAgICAgcm93cyA9IHVzZXJSb3dWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZighTnVtYmVyKGlzTmFOKHVzZXJDb2x1bW5WYWx1ZSkpICYmIHVzZXJDb2x1bW5WYWx1ZSAhPSAnJyAgJiYgdXNlckNvbHVtblZhbHVlID49IDEwICYmIHVzZXJDb2x1bW5WYWx1ZSA8PSAxNyl7XG4gICAgXG4gICAgICAgICAgICBjb2x1bW5zID0gdXNlckNvbHVtblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBjb21tb25GdW5jKCfQqNC40YDQuNC90LAg0Lgg0LLRi9GB0L7RgtCwINC00L7Qu9C20L3RiyDQsdGL0YLRjCDQvtGCIDEwINC00L4gMTcnKVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYobWVkaWFRdWVyeTMyMC5tYXRjaGVzICYmIG1lZGlhUXVlcnk0MjUubWF0Y2hlcyAmJiBtZWRpYVF1ZXJ5NzY4Lm1hdGNoZXMgJiYgIW1lZGlhUXVlcnkxMDI0Lm1hdGNoZXMpe1xuICAgICAgICBjb25zb2xlLmxvZygnTElUTEUgREVTS1RPUDogNzY4IHRvIDEwMjMnKTtcbiAgICAgICAgaWYoIU51bWJlcihpc05hTih1c2VyUm93VmFsdWUpKSAmJiB1c2VyUm93VmFsdWUgIT0gJycgJiYgdXNlclJvd1ZhbHVlID49IDE1ICYmIHVzZXJSb3dWYWx1ZSA8PSAyMyl7XG5cbiAgICAgICAgICAgIHJvd3MgPSB1c2VyUm93VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIU51bWJlcihpc05hTih1c2VyQ29sdW1uVmFsdWUpKSAmJiB1c2VyQ29sdW1uVmFsdWUgIT0gJycgICYmIHVzZXJDb2x1bW5WYWx1ZSA+PSAxNSAmJiB1c2VyQ29sdW1uVmFsdWUgPD0gMjMpe1xuICAgIFxuICAgICAgICAgICAgY29sdW1ucyA9IHVzZXJDb2x1bW5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgY29tbW9uRnVuYygn0KjQuNGA0LjQvdCwINC4INCy0YvRgdC+0YLQsCDQtNC+0LvQttC90Ysg0LHRi9GC0Ywg0L7RgiAxNSDQtNC+IDIzJylcbiAgICAgICAgfVxuICAgIH0gXG4gICAgZWxzZSBpZihtZWRpYVF1ZXJ5MzIwLm1hdGNoZXMgJiYgbWVkaWFRdWVyeTQyNS5tYXRjaGVzICYmIG1lZGlhUXVlcnk3NjgubWF0Y2hlcyAmJiBtZWRpYVF1ZXJ5MTAyNC5tYXRjaGVzKXtcbiAgICAgICAgY29uc29sZS5sb2coJ0xJVExFIERFU0tUT1A6IDc2OCB0byAxMDIzJyk7XG4gICAgICAgIGlmKCFOdW1iZXIoaXNOYU4odXNlclJvd1ZhbHVlKSkgJiYgdXNlclJvd1ZhbHVlICE9ICcnICYmIHVzZXJSb3dWYWx1ZSA+PSAxNSAmJiB1c2VyUm93VmFsdWUgPD0gMjcpe1xuXG4gICAgICAgICAgICByb3dzID0gdXNlclJvd1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFOdW1iZXIoaXNOYU4odXNlckNvbHVtblZhbHVlKSkgJiYgdXNlckNvbHVtblZhbHVlICE9ICcnICAmJiB1c2VyQ29sdW1uVmFsdWUgPj0gMTUgJiYgdXNlckNvbHVtblZhbHVlIDw9IDI3KXtcbiAgICBcbiAgICAgICAgICAgIGNvbHVtbnMgPSB1c2VyQ29sdW1uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGNvbW1vbkZ1bmMoJ9Co0LjRgNC40L3QsCDQuCDQstGL0YHQvtGC0LAg0LTQvtC70LbQvdGLINCx0YvRgtGMINC+0YIgMTUg0LTQviAyNycpXG4gICAgICAgIH1cbiAgICB9IFxuICAgIFxuXG4gICAgaWYocm93cyAmJiBjb2x1bW5zKXtcbiAgICAgICAgbmF2QnV0dG9ucy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgaW5pdFBhcmFtc0JveC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBiZWdpbldvcmxkKCk7XG5cblxuXG4gICAgfVxuICAgIFxufSlcblxuXG5cblxuICAgICAgICAvLyBGdW5jdGlvbiB0aGF0IGNoYW5nZSBzcGVlZFxuICAgICAgICBsaWZlU3BlZWQub25jaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBsaWZlU3BlZWRWYWx1ZSA9IGxpZmVTcGVlZC52YWx1ZTtcbiAgICAgICAgfVxuXG5cblxuICAgICAgICAvLyBjcmVhdGUgMkQgQXJyYXlzXG4gICAgICAgIGxldCBjdXJyZW50R2VuZXJhdGlvbiA9IFtyb3dzXTtcbiAgICAgICAgbGV0IG5leHRHZW5lcmF0aW9uID0gW3Jvd3NdO1xuXG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlR2VuZXJhdGlvbkFycmF5cygpe1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50R2VuZXJhdGlvbltpXSA9IG5ldyBBcnJheShjb2x1bW5zKTtcbiAgICAgICAgICAgICAgICBuZXh0R2VuZXJhdGlvbltpXSA9IG5ldyBBcnJheShjb2x1bW5zKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0aWFsR2VuZXJhdGlvbkFycmF5cygpe1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNvbHVtbnM7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50R2VuZXJhdGlvbltpXVtrXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5leHRHZW5lcmF0aW9uW2ldW2tdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIENyZWF0ZSB3b3JsZCBieSB0YWJsZXNcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlV29ybGQoKXtcbiAgICAgICAgICAgIGxldCB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgICAgICAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3dvcmxkR3JpZCcpO1xuICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8cm93czsgaSsrKXtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgayA9IDA7IGsgPCBjb2x1bW5zOyBrKyspe1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0QXR0cmlidXRlKCdpZCcsIGkgKyAnXycgKyBrKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2RlYWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQoY2VsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmxkLmFwcGVuZENoaWxkKHRhYmxlKTtcbiAgICAgICAgICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2VsbENsaWNrKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkRXZlbnRMaXN0ZW5lclxuICAgICAgICBmdW5jdGlvbiBjZWxsQ2xpY2soZGF0YSkge1xuICAgICAgICAgICAgbGV0IGxvYyA9IGRhdGEudGFyZ2V0LmlkLnNwbGl0KFwiX1wiKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGxvYyk7XG4gICAgICAgICAgICBsZXQgcm93ID0gTnVtYmVyKGxvY1swXSk7Ly9HZXQgaVxuICAgICAgICAgICAgbGV0IGNvbCA9IE51bWJlcihsb2NbMV0pOy8vR2V0IGpcbiAgICAgICAgICAgIC8vIFRvZ2dsZSBjZWxsIGFsaXZlIG9yIGRlYWRcbiAgICAgICAgICAgIGlmKGRhdGEudGFyZ2V0LmxvY2FsTmFtZT09PSd0ZCcpe1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnRhcmdldC5jbGFzc05hbWU9PT0nYWxpdmUnKXtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50YXJnZXQuc2V0QXR0cmlidXRlKCdjbGFzcycsICdkZWFkJyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHZW5lcmF0aW9uW3Jvd11bY29sXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGFyZ2V0LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnYWxpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdlbmVyYXRpb25bcm93XVtjb2xdID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgLy8gQ2hla2luZyBmb3IgbmVpZ2hib3JzIGFuZCBleHBlY3QgdGhlIHJ1bGVzXG4gICAgICAgIGZ1bmN0aW9uIGdldE5laWdoYm9yc0NvdW50ZXIocm93LCBjb2wpIHtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgbnJvdz1OdW1iZXIocm93KTtcbiAgICAgICAgICAgIGxldCBuY29sPU51bWJlcihjb2wpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGFyZSBub3QgYXQgdGhlIGZpcnN0IHJvd1xuICAgICAgICAgICAgICAgIGlmIChucm93IC0gMSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG9wIG5laWdoYm9yXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHZW5lcmF0aW9uW25yb3cgLSAxXVtuY29sXSA9PSAxKSBcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXJlIG5vdCBpbiB0aGUgZmlyc3QgY2VsbFxuICAgICAgICAgICAgICAgIC8vIFVwcGVyIGxlZnQgY29ybmVyXG4gICAgICAgICAgICAgICAgaWYgKG5yb3cgLSAxID49IDAgJiYgbmNvbCAtIDEgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vQ2hlY2sgdXBwZXIgbGVmdCBuZWlnaGJvclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50R2VuZXJhdGlvbltucm93IC0gMV1bbmNvbCAtIDFdID09IDEpIFxuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXJlIG5vdCBvbiB0aGUgZmlyc3Qgcm93IGxhc3QgY29sdW1uXG4gICAgICAgICAgICAgICAgLy8gVXBwZXIgcmlnaHQgY29ybmVyXG4gICAgICAgICAgICAgICAgaWYgKG5yb3cgLSAxID49IDAgJiYgbmNvbCArIDEgPCBjb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgLy9DaGVjayB1cHBlciByaWdodCBuZWlnaGJvclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEdlbmVyYXRpb25bbnJvdyAtIDFdW25jb2wgKyAxXSA9PSAxKSBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXJlIG5vdCBvbiB0aGUgZmlyc3QgY29sdW1uXG4gICAgICAgICAgICBpZiAobmNvbCAtIDEgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vQ2hlY2sgbGVmdCBuZWlnaGJvclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50R2VuZXJhdGlvbltucm93XVtuY29sIC0gMV0gPT0gMSkgXG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXJlIG5vdCBvbiB0aGUgbGFzdCBjb2x1bW5cbiAgICAgICAgICAgIGlmIChuY29sICsgMSA8IGNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAvL0NoZWNrIHJpZ2h0IG5laWdoYm9yXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHZW5lcmF0aW9uW25yb3ddW25jb2wgKyAxXSA9PSAxKSBcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGFyZSBub3Qgb24gdGhlIGJvdHRvbSBsZWZ0IGNvcm5lclxuICAgICAgICAgICAgaWYgKG5yb3cgKyAxIDwgcm93cyAmJiBuY29sIC0gMSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy9DaGVjayBib3R0b20gbGVmdCBuZWlnaGJvclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50R2VuZXJhdGlvbltucm93ICsgMV1bbmNvbCAtIDFdID09IDEpIFxuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXJlIG5vdCBvbiB0aGUgYm90dG9tIHJpZ2h0XG4gICAgICAgICAgICBpZiAobnJvdyArIDEgPCByb3dzICYmIG5jb2wgKyAxIDwgY29sdW1ucykge1xuICAgICAgICAgICAgICAgIC8vQ2hlY2sgYm90dG9tIHJpZ2h0IG5laWdoYm9yXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHZW5lcmF0aW9uW25yb3cgKyAxXVtuY29sICsgMV0gPT0gMSkgXG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBhcmUgbm90IG9uIHRoZSBsYXN0IHJvd1xuICAgICAgICAgICAgaWYgKG5yb3cgKyAxIDwgcm93cykge1xuICAgICAgICAgICAgICAgIC8vQ2hlY2sgYm90dG9tIG5laWdoYm9yXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHZW5lcmF0aW9uW25yb3cgKyAxXVtuY29sXSA9PSAxKSBcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERlZmluZSBjb25kaXRpb25zIG9mIGNlbGxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVOZXh0R2VuZXJhdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcm93IGluIGN1cnJlbnRHZW5lcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgaW4gY3VycmVudEdlbmVyYXRpb25bcm93XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5laWdoYm9ycyA9IGdldE5laWdoYm9yc0NvdW50ZXIocm93LCBjb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJ1bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgQWxpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEdlbmVyYXRpb25bcm93XVtjb2xdID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5laWdoYm9ycyA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRHZW5lcmF0aW9uW3Jvd11bY29sXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmVpZ2hib3JzID09IDIgfHwgbmVpZ2hib3JzID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRHZW5lcmF0aW9uW3Jvd11bY29sXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmVpZ2hib3JzID4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEdlbmVyYXRpb25bcm93XVtjb2xdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEdlbmVyYXRpb25bcm93XVtjb2xdID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgRGVhZCBvciBFbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVpZ2hib3JzID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb3BvZ2F0ZSB0aGUgc3BlY2llc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEdlbmVyYXRpb25bcm93XVtjb2xdID0gMTsvL0JpcnRoP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgIC8vIFxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUN1cnJlbnRHZW5lcmF0aW9uKCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGxldCByb3cgaW4gY3VycmVudEdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgaW4gY3VycmVudEdlbmVyYXRpb25bcm93XSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgZ2VuZXJhdGlvbiB3aXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXN1bHRzIG9mIGNyZWF0ZU5leHRHZW4gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdlbmVyYXRpb25bcm93XVtjb2xdID0gbmV4dEdlbmVyYXRpb25bcm93XVtjb2xdO1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgbmV4dEdlbiBiYWNrIHRvIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgIG5leHRHZW5lcmF0aW9uW3Jvd11bY29sXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVXb3JsZCgpIHtcbiAgICAgICAgICAgIGxldCBjZWxsPScnO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93IGluIGN1cnJlbnRHZW5lcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sIGluIGN1cnJlbnRHZW5lcmF0aW9uW3Jvd10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2VsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJvdyArICdfJyArIGNvbCk7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHtyb3d9XyR7Y29sfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEdlbmVyYXRpb25bcm93XVtjb2xdID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0QXR0cmlidXRlKCdjbGFzcycsICdkZWFkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0QXR0cmlidXRlKCdjbGFzcycsICdhbGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuXG4gICAgICAgIC8vIGNyZWF0ZSBzdGFydExpZmUgZnVjbnRpb25cblxuICAgICAgICBmdW5jdGlvbiBzdGFydExpZmUoKXtcbiAgICAgICAgICAgIGNyZWF0ZU5leHRHZW5lcmF0aW9uKCk7Ly9BcHBseSB0aGUgcnVsZXNcbiAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRHZW5lcmF0aW9uKCk7Ly9TZXQgQ3VycmVudCB2YWx1ZXMgZnJvbSBuZXcgZ2VuZXJhdGlvblxuICAgICAgICAgICAgdXBkYXRlV29ybGQoKTsvL1VwZGF0ZSB0aGUgd29ybGQgdmlld1xuICAgICAgICAgICAgLy8gY2hlY2soKVxuICAgICAgICAgICAgaWYoc3RhcnRlZCl7XG4gICAgICAgICAgICAgICAgdGltZXIgPSAoc2V0VGltZW91dChzdGFydExpZmUsIGxpZmVTcGVlZFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0VGltZW91dChjaGVjaywgbGlmZVNwZWVkVmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gRnVuY3Rpb24gc3RhcnQgYW5kIHN0b3AgbGlmZVxuICAgICAgICBmdW5jdGlvbiBzdGFydEFuZFN0b3AoKXtcbiAgICAgICAgICAgIGlmKCFzdGFydGVkKXtcbiAgICAgICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFydEJ0bi5pbm5lclRleHQgPSAn0J7RgdGC0LDQvdC+0LLQuNGC0Ywg0LjQs9GA0YsnO1xuICAgICAgICAgICAgICAgIHN0YXJ0TGlmZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhcnRCdG4uaW5uZXJUZXh0ID0gJ9Cd0LDRh9Cw0YLRjCDQuNCz0YDRgyEnO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbG9hZCBwYWdlIGFuZGUgcmVzZXQgZGF0YVxuICAgICAgICBmdW5jdGlvbiByZXNldERhdGEoKXtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIG5hdkJ1dHRvbnMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGluaXRQYXJhbXNCb3guc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHN0YXJ0QW5kU3RvcCk7XG4gICAgICAgIHJlc2V0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcmVzZXREYXRhKTtcblxuXG4gICAgICAgIGZ1bmN0aW9uIGJlZ2luV29ybGQoKXtcbiAgICAgICAgICAgIGNyZWF0ZVdvcmxkKCk7XG4gICAgICAgICAgICBjcmVhdGVHZW5lcmF0aW9uQXJyYXlzKCk7XG4gICAgICAgICAgICBpbml0aWFsR2VuZXJhdGlvbkFycmF5cygpO1xuICAgICAgICB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///138\n")}},__webpack_exports__={};__webpack_modules__[138]()})();